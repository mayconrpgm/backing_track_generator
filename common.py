import os
import subprocess
import librosa
import soundfile as sf
import numpy as np
import logging
import re
from pytubefix import YouTube
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def download_audio(youtube_url, output_path):
    try:
        logging.info(f"Starting download of audio from URL: {youtube_url}")
        yt = YouTube(youtube_url)
        file_name = sanitize_folder_name(yt.title)
        download_folder = os.path.join(output_path, file_name)
        os.makedirs(download_folder, exist_ok=True)

        mp3_file = os.path.join(download_folder, f"{file_name}.mp3")
        if os.path.exists(mp3_file):
            logging.info(f"Audio file '{mp3_file}' already exists. Skipping download.")
            return mp3_file, download_folder

        audio_stream = yt.streams.filter(only_audio=True).first()
        audio_file = audio_stream.download(output_path=download_folder)
        base, ext = os.path.splitext(audio_file)
        os.rename(audio_file, mp3_file)
        logging.info(f"Audio downloaded successfully to '{mp3_file}'.")
        return mp3_file, download_folder
    except Exception as e:
        logging.error(f"Failed to download audio: {str(e)}")
        raise RuntimeError(f"Failed to download audio: {str(e)}")

def pitch_shift(audio_file, semitones, output_folder):
    try:
        logging.info(f"Starting pitch shift by {semitones} semitones for file: {audio_file}")
        shifted_file = os.path.join(output_folder, f"{os.path.splitext(os.path.basename(audio_file))[0]}_{semitones:+}st.mp3")
        if os.path.exists(shifted_file):
            logging.info(f"Pitch-shifted file '{shifted_file}' already exists. Skipping.")
            return shifted_file

        y, sr = librosa.load(audio_file, sr=None)
        y_shifted = librosa.effects.pitch_shift(y, sr=sr, n_steps=semitones)
        sf.write(shifted_file, y_shifted, sr)
        logging.info(f"Pitch shift completed. Output file: '{shifted_file}'.")
        return shifted_file
    except Exception as e:
        logging.error(f"Pitch shifting failed: {str(e)}")
        raise RuntimeError(f"Pitch shifting failed: {str(e)}")

def separate_stems(audio_file, model, output_folder):
    try:
        logging.info(f"Starting stem separation for file: {audio_file} using model: {model}")
        stems_output = os.path.join(output_folder, 'stems')
        output_model_path = os.path.join(stems_output, model)

        if os.path.exists(output_model_path):
            logging.info(f"Stems generated by model at '{output_model_path}' already exists. Skipping.")
            return output_model_path

        if not os.path.exists(stems_output):
            os.makedirs(stems_output)

        # Run Demucs to separate stems
        subprocess.run(['demucs', '-n', model, '--mp3', '-o', stems_output, audio_file], check=True)

        # Special handling for htdemucs_ft model: move .mp3 files up and remove extra folder
        if model.startswith('htdemucs_ft'):
            # After demucs, output is: stems/model/audio_file_name/*.mp3
            audio_file_name = os.path.splitext(os.path.basename(audio_file))[0]
            extra_folder = os.path.join(output_model_path, audio_file_name)
            if os.path.exists(extra_folder):
                for f in os.listdir(extra_folder):
                    if f.endswith('.mp3'):
                        src = os.path.join(extra_folder, f)
                        dst = os.path.join(output_model_path, f)
                        os.rename(src, dst)
                # Remove the now-empty extra folder
                os.rmdir(extra_folder)

        logging.info(f"Stem separation completed. Output folder: {output_model_path}")
        return output_model_path
    except subprocess.CalledProcessError as e:
        logging.error(f"Stem separation failed: {str(e)}")
        raise RuntimeError(f"Stem separation failed: {str(e)}")


def create_beat_track(audio_file, output_folder):
    try:
        logging.info(f"Starting creation of beat track for file: {audio_file}")
        beat_track_file = os.path.join(output_folder, f"{os.path.splitext(os.path.basename(audio_file))[0]}_beat_track.mp3")
        beat_track_file_mixed = os.path.join(output_folder, f"{os.path.splitext(os.path.basename(audio_file))[0]}_beat_track_mixed.mp3")
        if os.path.exists(beat_track_file):
            logging.info(f"Beat track '{beat_track_file}' already exists. Skipping.")
            return beat_track_file

        # Load audio file
        y, sr = librosa.load(audio_file, sr=None)

        # Detect beat frames
        tempo, beat_frames = librosa.beat.beat_track(y=y, sr=sr)
        logging.info(f"Detected tempo: {tempo}")

        # Create a click track
        click_audio = librosa.clicks(frames=beat_frames, sr=sr, length=len(y))

        # Ensure the click track is the same length as the original audio
        if len(click_audio) < len(y):
            click_audio = np.pad(click_audio, (0, len(y) - len(click_audio)), mode='constant')
        elif len(click_audio) > len(y):
            click_audio = click_audio[:len(y)]

        # Mix the original audio with the click track
        mixed_audio = y + click_audio

        # Save the standalone beat track
        sf.write(beat_track_file, click_audio, sr)
        # Save the beat track mixed with the original audio
        sf.write(beat_track_file_mixed, mixed_audio, sr)
        logging.info(f"Beat track creation completed. Files: '{beat_track_file}' and '{beat_track_file_mixed}'.")
        return beat_track_file
    except Exception as e:
        logging.error(f"Creating beat track failed: {str(e)}")
        raise RuntimeError(f"Creating beat track failed: {str(e)}")


def create_backing_track(stems_folder, exclude_stem, output_folder, include_beat=False, beat_file=None):
    try:
        logging.info(f"Starting creation of backing track, excluding stem: {exclude_stem}")

        audio_title = Path(stems_folder).parts[-3]
        backing_track_file = os.path.join(output_folder, f"{audio_title}_backing_track_without_{exclude_stem}.mp3")

        if os.path.exists(backing_track_file):
            logging.info(f"Backing track file '{backing_track_file}' already exists. Skipping.")
            return backing_track_file
        
        # List all stem files in the stems folder
        logging.info(f"Checking stems folder: {stems_folder}")
        stem_files = [os.path.join(stems_folder, f) for f in os.listdir(stems_folder) if f.endswith('.mp3')]

        # Filter out the stem file to be excluded
        stem_files = [f for f in stem_files if exclude_stem not in os.path.basename(f)]
        if not stem_files:
            raise RuntimeError("No stems available to create a backing track.")
        
        # Load all the remaining stem audio files
        audio_data = []
        sample_rate = None
        for file_path in stem_files:
            y, sr = librosa.load(file_path, sr=None)
            audio_data.append(y)
            sample_rate = sr
        
        # Mix the audio data together
        mixed_audio = np.sum(audio_data, axis=0)
        
        # Optionally add the beat track
        if include_beat and beat_file:
            logging.info("Including beat track in backing track.")
            beat_audio, _ = librosa.load(beat_file, sr=sample_rate)

            # Pad beat track if necessary
            if len(beat_audio) < len(mixed_audio):
                beat_audio = np.pad(beat_audio, (0, len(mixed_audio) - len(beat_audio)), mode='constant')
            elif len(beat_audio) > len(mixed_audio):
                beat_audio = beat_audio[:len(mixed_audio)]

            # Add the beat track to the mix
            mixed_audio += beat_audio

        # Save the backing track
        sf.write(backing_track_file, mixed_audio, sample_rate)
        logging.info(f"Backing track creation completed. File: {backing_track_file}")
        return backing_track_file
    except Exception as e:
        logging.error(f"Backing track creation failed: {str(e)}")
        raise RuntimeError(f"Backing track creation failed: {str(e)}")

def sanitize_folder_name(folder_name):
    """
    Sanitizes a string to make it suitable for use as a folder name.
    Removes or replaces invalid characters and trims whitespace.
    
    Args:
        folder_name (str): The original folder name.
    
    Returns:
        str: The sanitized folder name.
    """
    # Replace invalid characters with an underscore
    sanitized_name = re.sub(r'[\\/:*?"<>|]', '_', folder_name)
    # Trim leading and trailing whitespace
    sanitized_name = sanitized_name.strip()
    return sanitized_name

def add_start_beat_to_audio(input_file, output_file, num_beats=4):
    """Add a specified number of metronome beats to the start of an audio file."""
    # Load the original audio
    audio, sr = librosa.load(input_file, sr=None)
    # Remove leading and trailing silence
    audio, _ = librosa.effects.trim(audio, top_db=20)
    # Automatically detect the tempo of the audio
    tempo, _ = librosa.beat.beat_track(y=audio, sr=sr)
    logging.info(f"Detected tempo: {tempo} BPM for start beat.")
    # Calculate the duration of each beat in seconds
    beat_duration = 60.0 / tempo
    # Generate the click sound for one beat
    t = np.linspace(0, 0.1, int(sr * 0.1), endpoint=False)
    click_sound = 0.5 * np.sin(2 * np.pi * 440 * t)  # 440 Hz sine wave, 100 ms
    # Create a silent segment to separate clicks (duration of beat minus click duration)
    silence_duration = max(0, beat_duration - 0.1)
    silence_length = int(float(sr * silence_duration))
    silence = np.zeros(silence_length, dtype=np.float32)
    # Create the full metronome beat pattern (alternating click + silence)
    metronome = np.concatenate([np.concatenate([click_sound, silence]) for _ in range(num_beats)])
    # Concatenate the metronome with the original audio
    output_audio = np.concatenate([metronome, audio])
    # Save the output audio to a file
    sf.write(output_file, output_audio, sr)
    logging.info(f"Audio saved to {output_file} with {num_beats} beats added at the detected tempo of {tempo} BPM.")